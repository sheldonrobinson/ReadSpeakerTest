<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReadSpeaker TTS: Optimization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReadSpeaker TTS
   </div>
   <div id="projectbrief">Realtime TTS in Unreal Engine.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Main Page</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Optimization </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This section details usage of the TTS can be optimized to increase performance or reduce memory usage. </p>
<h1><a class="anchor" id="say_sayasync"></a>
Say vs. SayAsync</h1>
<p >Using <a class="el" href="classUTTSSpeaker.html#a655976067c26abe7b55a2870bcc61f23">UTTSSpeaker::SayAsync</a> offloads the computationally heavy operation of synthesizing to a background thread. Using <a class="el" href="classUTTSSpeaker.html#a895631c0abc06305638f6170b71143ba">UTTSSpeaker::Say</a>, the synthesis takes place on the main thread. Depending on your use case, you might want to use either of these variants. If you rely on a steady framerate, <a class="el" href="classUTTSSpeaker.html#a655976067c26abe7b55a2870bcc61f23">UTTSSpeaker::SayAsync</a> is to prefer as only a small fraction of time is spent in the main thread. If you want to rely on the speech being played the next frame after the call, <a class="el" href="classUTTSSpeaker.html#a895631c0abc06305638f6170b71143ba">UTTSSpeaker::Say</a> should be used. </p>
<h1><a class="anchor" id="manual_engine"></a>
Loading/Unloading voice engines</h1>
<p >In the case that the engine is not currently loaded into memory upon synthesis, it will load into memory automatically. To avoid occupying memory the voice engine is then immediately unloaded once it has been determined that it is no longer used. The loading operation can be computationally expensive, as such there may be cases where it is more benefitial to keep the engine loaded in memory for a longer period of time. To manually control when a voice engine gets loaded and unloaded from memory, use <a class="el" href="classUTTSEngine.html#a60cb7f881d806a6788c304d0290cc3b3">UTTSEngine::LoadEngine()</a> and <a class="el" href="classUTTSEngine.html#a7df1361c43b282cfe5f6dbb43cb55724">UTTSEngine::UnloadEngine()</a>. </p>
<h1><a class="anchor" id="manual_conversion"></a>
Manual TTS conversion</h1>
<p >There might be cases where the workload of performing the synthesis should be separated from playing the audio. For these purposes, use the <a class="el" href="classUTTSConverter.html">UTTSConverter</a> class. This class is used by <a class="el" href="classUTTSSpeaker.html#a895631c0abc06305638f6170b71143ba">UTTSSpeaker::Say</a> and <a class="el" href="classUTTSSpeaker.html#a655976067c26abe7b55a2870bcc61f23">UTTSSpeaker::SayAsync</a> internally to perform synthesis. An example is shown below. </p><div class="fragment"><div class="line">void ConverterTest(){</div>
<div class="line">     FReadSpeakerTTSModule::Init();</div>
<div class="line">     TArray&lt;TArray&lt;int16&gt; results;</div>
<div class="line">     UTTSConverter *converter = NewObject&lt;UTTSConverter&gt;;</div>
<div class="line">     UTTSEngine *Engine = FReadSpeakerTTSModule::GetEngine(&quot;ashley&quot;,&quot;d16&quot;);</div>
<div class="line">     converter.Engine = Engine;</div>
<div class="line">     converter.Volume = 250;</div>
<div class="line">     converter.Pitch = 50;</div>
<div class="line">     converter.Speed = 125;</div>
<div class="line">     converter.Pause = 0;</div>
<div class="line">     converter.CommaPause = 0;</div>
<div class="line">     converter.TextType = TextType.Normal;</div>
<div class="line">     for(int i = 0; i &lt; 100; i++){</div>
<div class="line">         converter.Pitch = 50 + (i*2);</div>
<div class="line">         converter.Text = FString::Format(&quot;%d&quot;, i);</div>
<div class="line">         converter.ConvertToBuffer();</div>
<div class="line">         results.Add(converter.GetAudioData());</div>
<div class="line">     }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The above code would result in an array of 100 audio data buffer each containing the audio data that was produced by reading the index of the list in increasing pitch. </p>
<h2><a class="anchor" id="mutlithreading"></a>
Multithreading</h2>
<p >When converting on threads on other than the main thread make sure to use a seprate <a class="el" href="classUTTSConverter.html">UTTSConverter</a> for each thread. Also consider using the thread safe implementation of ConvertToBuffer <a class="el" href="classUTTSConverter.html#a49c5f0db1b4b82a1f22199442e0ceb6a">UTTSConverter::ConvertToBufferAsync</a>. This will avoid race conditions by locking voice engines to perform one conversion at a time. Different voice engines can convert in parallel. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
